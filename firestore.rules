rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // TestFlight requests - Allow public write for download app page
    match /testflight_requests/{requestId} {
      allow create: if true; // Anyone can submit a TestFlight request
      allow read, update, delete: if request.auth != null; // Only authenticated users (admins) can read/update
    }
    
    // App Settings - Read access for authenticated users, write access for super admins only
    match /app_settings/{settingId} {
      allow read: if request.auth != null; // All authenticated users can read settings
      allow write: if request.auth != null && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'super_admin';
    }
    
    // Opportunity Stage History - Read-only for admins, write only by backend
    match /opportunityStageHistory/{historyId} {
      allow read: if request.auth != null && 
        (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'super_admin' ||
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');
      allow write: if false; // Only backend/Cloud Functions can write
    }
    
    // Products - Admin only access for performance cost tracking
    match /products/{productId} {
      allow read, write: if request.auth != null && isAdmin();
    }
    
    // Ad Performance Costs - Admin only access for budget and profit tracking
    match /adPerformanceCosts/{costId} {
      allow read, write: if request.auth != null && isAdmin();
    }
    
    // Ad Performance - Combined Facebook + GHL data, Admin only access
    match /adPerformance/{adId} {
      allow read: if request.auth != null && isAdmin();
      allow write: if request.auth != null && isAdmin();
    }
    
    // Helper function to check if user is admin
    function isAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'super_admin' ||
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    // Google Calendar Tokens & Paystack Subaccount - Only practitioner can access their own data
    match /users/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow write: if request.auth != null && request.auth.uid == userId;
      
      // Ensure Google Calendar tokens are only accessible to the token owner
      allow read: if request.auth != null && request.auth.uid == userId &&
        !('googleRefreshToken' in resource.data) || request.auth.uid == userId;
      
      // Prevent reading other users' Google tokens
      allow update: if request.auth != null && request.auth.uid == userId &&
        (!('googleRefreshToken' in request.resource.data) || 
         request.auth.uid == userId);
      
      // Paystack subaccount fields (paystackSubaccountCode, bankAccountNumber, etc.)
      // are protected by the userId match above - only the user can access their own data
    }
    
    // Appointments - Can include sync status and Google event ID
    match /appointments/{appointmentId} {
      allow read: if request.auth != null;
      
      // Allow unauthenticated read for opt_in appointments (needed for contract signing flow)
      // This allows the system to read appointment data when moving from opt_in to deposit_requested
      allow read: if resource.data.currentStage == 'opt_in';
      
      // Allow unauthenticated read for deposit confirmation flow
      // This allows customers to validate their token when clicking Yes/No links
      allow read: if resource.data.currentStage == 'deposit_requested' && 
                     resource.data.depositConfirmationStatus == 'pending';
      
      // Allow unauthenticated read for finance deposit confirmation
      // Finance needs to read appointments in deposit_requested regardless of confirmation status
      allow read: if resource.data.currentStage == 'deposit_requested';
      
      allow create: if request.auth != null;

      // Allow authenticated updates by owner or admin
      allow update: if request.auth != null && 
        (resource.data.practitionerId == request.auth.uid || isAdmin());

      // Allow unauthenticated updates ONLY for automatic stage movement from contract signing
      // This allows the system to move appointments from opt_in to deposit_requested
      // when a contract is signed (unauthenticated contract signing flow)
      allow update: if resource.data.currentStage == 'opt_in' && 
                       request.resource.data.currentStage == 'deposit_requested';

      // Allow unauthenticated updates for deposit confirmation (Yes/No response)
      // This allows updating deposit confirmation fields when customer clicks Yes/No in email
      // Stage must remain deposit_requested and only specific fields can be modified
      allow update: if resource.data.currentStage == 'deposit_requested' && 
                       request.resource.data.currentStage == 'deposit_requested' &&
                       // Ensure only deposit confirmation fields, stageHistory and updatedAt are being modified
                       request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['depositConfirmationStatus', 'depositConfirmationRespondedAt', 'stageHistory', 'updatedAt']) &&
                       // Validate depositConfirmationStatus is changing from 'pending' to 'confirmed' or 'declined'
                       resource.data.depositConfirmationStatus == 'pending' &&
                       (request.resource.data.depositConfirmationStatus == 'confirmed' || 
                        request.resource.data.depositConfirmationStatus == 'declined');

      // Allow finance to confirm deposit received (unauthenticated)
      // This allows moving appointments from deposit_requested to deposit_made
      allow update: if resource.data.currentStage == 'deposit_requested' && 
                       request.resource.data.currentStage == 'deposit_made' &&
                       request.resource.data.depositPaid == true &&
                       // Only allow updating specific fields for deposit confirmation
                       request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['currentStage', 'stageEnteredAt', 'depositPaid', 'stageHistory', 'updatedAt']);

      allow delete: if request.auth != null && 
        (resource.data.practitionerId == request.auth.uid || isAdmin());
    }
    
    // Payments - Practitioners can only access their own payments
    match /payments/{paymentId} {
      // Practitioners can read their own payments
      allow read: if request.auth != null && 
        (resource.data.practitionerId == request.auth.uid || isAdmin());
      
      // Practitioners can create payments for their appointments
      allow create: if request.auth != null && 
        request.resource.data.practitionerId == request.auth.uid;
      
      // Practitioners can update their own payments (e.g., mark as paid, cancel)
      allow update: if request.auth != null && 
        (resource.data.practitionerId == request.auth.uid || isAdmin()) &&
        // Ensure practitionerId cannot be changed
        request.resource.data.practitionerId == resource.data.practitionerId;
      
      // Only admins can delete payments
      allow delete: if request.auth != null && isAdmin();
    }
    
    // Forms - Public read access for active forms, authenticated write for admins
    match /forms/{formId} {
      // Allow public read access to active forms (for public form page)
      allow read: if resource.data.status == 'active';
      // Allow authenticated admins to read all forms (including drafts/inactive)
      allow read: if request.auth != null && isAdmin();
      // Only authenticated admins can create/update/delete forms
      allow write: if request.auth != null && isAdmin();
    }
    
    // Form Submissions - Public create (for form submissions), admin read/write
    match /formSubmissions/{submissionId} {
      // Allow public create (anyone can submit a form)
      allow create: if true;
      // Only authenticated admins can read submissions
      allow read: if request.auth != null && isAdmin();
      // Only authenticated admins can update/delete submissions
      allow update, delete: if request.auth != null && isAdmin();
    }
    
    // Leads - Public create (for form submissions), admin read/write
    match /leads/{leadId} {
      // Allow public create (form submissions automatically create leads)
      allow create: if true;
      // Only authenticated admins can read leads
      allow read: if request.auth != null && isAdmin();
      // Only authenticated admins can update/delete leads
      allow update, delete: if request.auth != null && isAdmin();
    }
    
    // Lead Channels - Public read/write for default channel, admin full access
    match /leadChannels/{channelId} {
      // Allow public read access to default channel (for form submissions)
      allow read: if channelId == 'new_leads';
      // Allow public write (create/update) for default channel only (initializeDefaultChannel uses .set())
      allow write: if channelId == 'new_leads';
      // Allow authenticated admins to read all channels
      allow read: if request.auth != null && isAdmin();
      // Allow authenticated admins to write all channels
      allow write: if request.auth != null && isAdmin();
    }
    
    // Orders - Public read for installation booking, authenticated write
    match /orders/{orderId} {
      // Allow public read access for installation booking flow
      // Customers need to read their order to select installation dates
      allow read: if true;
      
      // Allow public update ONLY for installation date selection
      // This allows customers to submit their preferred installation dates
      // The update moves the order to priority_shipment stage and records the selected dates
      allow update: if resource.data.installBookingStatus == 'pending' &&
                       request.resource.data.installBookingStatus == 'dates_selected' &&
                       request.resource.data.currentStage == 'priority_shipment' &&
                       // Only allow updating specific fields for installation booking
                       request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['installBookingStatus', 'customerSelectedDates', 'currentStage', 'stageEnteredAt', 'stageHistory', 'updatedAt']);
      
      // Authenticated users (admins/staff) can do everything
      allow read, write: if request.auth != null;
    }
    
    // Contracts - Public read access, restricted write access
    match /contracts/{contractId} {
      // Allow public read access
      allow read: if true;

      // Allow public UPDATE only for pending/viewed contracts (for signing)
      allow update: if resource.data.status in ['pending', 'viewed'] && 
                       !resource.data.hasSigned;

      // Allow updating pdfUrl after contract is signed (for PDF generation)
      // Only allow updating the pdfUrl field, nothing else
      allow update: if resource.data.hasSigned == true &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pdfUrl']);

      // Only authenticated admins can create/delete contracts
      allow create, delete: if request.auth != null && isAdmin();
    }
    
    // SUPER PERMISSIVE RULES - Allow all authenticated users to do everything
    match /{document=**} {
      allow read, write: if request.auth != null;
    }
  }
}