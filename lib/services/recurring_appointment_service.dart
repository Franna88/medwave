import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/appointment.dart';

enum RecurrenceFrequency { daily, weekly, biweekly, monthly }

class RecurringAppointmentPattern {
  final String id;
  final String practitionerId;
  final String patientId;
  final RecurrenceFrequency frequency;
  final DateTime startDate;
  final DateTime? endDate;
  final int? occurrences;
  final String title;
  final String type;
  final int duration;
  final String? notes;
  final String? location;
  final List<int> daysOfWeek; // For weekly: 1=Monday, 7=Sunday
  final int dayOfMonth; // For monthly: 1-31
  final bool isActive;
  final DateTime createdAt;

  RecurringAppointmentPattern({
    required this.id,
    required this.practitionerId,
    required this.patientId,
    required this.frequency,
    required this.startDate,
    this.endDate,
    this.occurrences,
    required this.title,
    required this.type,
    required this.duration,
    this.notes,
    this.location,
    this.daysOfWeek = const [],
    this.dayOfMonth = 1,
    this.isActive = true,
    required this.createdAt,
  });

  Map<String, dynamic> toFirestore() {
    return {
      'practitionerId': practitionerId,
      'patientId': patientId,
      'frequency': frequency.name,
      'startDate': Timestamp.fromDate(startDate),
      'endDate': endDate != null ? Timestamp.fromDate(endDate!) : null,
      'occurrences': occurrences,
      'title': title,
      'type': type,
      'duration': duration,
      'notes': notes,
      'location': location,
      'daysOfWeek': daysOfWeek,
      'dayOfMonth': dayOfMonth,
      'isActive': isActive,
      'createdAt': Timestamp.fromDate(createdAt),
    };
  }

  factory RecurringAppointmentPattern.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return RecurringAppointmentPattern(
      id: doc.id,
      practitionerId: data['practitionerId'] ?? '',
      patientId: data['patientId'] ?? '',
      frequency: RecurrenceFrequency.values.firstWhere(
        (e) => e.name == data['frequency'],
        orElse: () => RecurrenceFrequency.weekly,
      ),
      startDate: (data['startDate'] as Timestamp).toDate(),
      endDate: data['endDate'] != null
          ? (data['endDate'] as Timestamp).toDate()
          : null,
      occurrences: data['occurrences'],
      title: data['title'] ?? '',
      type: data['type'] ?? '',
      duration: data['duration'] ?? 60,
      notes: data['notes'],
      location: data['location'],
      daysOfWeek: List<int>.from(data['daysOfWeek'] ?? []),
      dayOfMonth: data['dayOfMonth'] ?? 1,
      isActive: data['isActive'] ?? true,
      createdAt: (data['createdAt'] as Timestamp).toDate(),
    );
  }
}

class RecurringAppointmentService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Create a recurring appointment pattern
  Future<String?> createRecurringPattern(
    RecurringAppointmentPattern pattern,
  ) async {
    try {
      final docRef = await _firestore
          .collection('recurringAppointments')
          .add(pattern.toFirestore());

      print('✅ Recurring pattern created: ${docRef.id}');
      return docRef.id;
    } catch (e) {
      print('❌ Error creating recurring pattern: $e');
      return null;
    }
  }

  /// Generate appointments from recurring pattern
  Future<List<Appointment>> generateAppointmentsFromPattern(
    RecurringAppointmentPattern pattern,
  ) async {
    final List<Appointment> appointments = [];
    DateTime currentDate = pattern.startDate;
    int count = 0;

    while (true) {
      // Check if we've reached the end date
      if (pattern.endDate != null && currentDate.isAfter(pattern.endDate!)) {
        break;
      }

      // Check if we've reached the max occurrences
      if (pattern.occurrences != null && count >= pattern.occurrences!) {
        break;
      }

      // Don't generate appointments more than 1 year in advance
      if (currentDate.isAfter(DateTime.now().add(const Duration(days: 365)))) {
        break;
      }

      // Create appointment for this occurrence
      final appointment = Appointment(
        id: '', // Will be generated by Firestore
        practitionerId: pattern.practitionerId,
        patientId: pattern.patientId,
        title: pattern.title,
        type: pattern.type,
        startTime: currentDate,
        endTime: currentDate.add(Duration(minutes: pattern.duration)),
        duration: pattern.duration,
        status: AppointmentStatus.scheduled,
        notes: pattern.notes,
        location: pattern.location,
        reminderSent: false,
        createdAt: DateTime.now(),
        recurringPatternId: pattern.id,
      );

      appointments.add(appointment);
      count++;

      // Calculate next occurrence
      currentDate = _getNextOccurrence(currentDate, pattern);
    }

    return appointments;
  }

  /// Calculate next occurrence based on frequency
  DateTime _getNextOccurrence(
    DateTime current,
    RecurringAppointmentPattern pattern,
  ) {
    switch (pattern.frequency) {
      case RecurrenceFrequency.daily:
        return current.add(const Duration(days: 1));

      case RecurrenceFrequency.weekly:
        if (pattern.daysOfWeek.isEmpty) {
          return current.add(const Duration(days: 7));
        }
        // Find next day of week
        DateTime next = current.add(const Duration(days: 1));
        while (!pattern.daysOfWeek.contains(next.weekday)) {
          next = next.add(const Duration(days: 1));
        }
        return next;

      case RecurrenceFrequency.biweekly:
        return current.add(const Duration(days: 14));

      case RecurrenceFrequency.monthly:
        // Add one month, keeping the same day
        int targetDay = pattern.dayOfMonth;
        DateTime next = DateTime(current.year, current.month + 1, 1);

        // Handle months with fewer days
        int daysInMonth = DateTime(next.year, next.month + 1, 0).day;
        if (targetDay > daysInMonth) {
          targetDay = daysInMonth;
        }

        return DateTime(
          next.year,
          next.month,
          targetDay,
          current.hour,
          current.minute,
        );
    }
  }

  /// Create appointments from pattern and save to Firestore
  Future<int> createAppointmentsFromPattern(
    RecurringAppointmentPattern pattern,
  ) async {
    try {
      final appointments = await generateAppointmentsFromPattern(pattern);
      int created = 0;

      final batch = _firestore.batch();
      for (final appointment in appointments) {
        final docRef = _firestore.collection('appointments').doc();
        batch.set(docRef, appointment.toFirestore());
        created++;
      }

      await batch.commit();
      print('✅ Created $created appointments from recurring pattern');
      return created;
    } catch (e) {
      print('❌ Error creating appointments from pattern: $e');
      return 0;
    }
  }

  /// Get recurring patterns for a practitioner
  Future<List<RecurringAppointmentPattern>> getPractitionerPatterns(
    String practitionerId,
  ) async {
    try {
      final snapshot = await _firestore
          .collection('recurringAppointments')
          .where('practitionerId', isEqualTo: practitionerId)
          .where('isActive', isEqualTo: true)
          .get();

      return snapshot.docs
          .map((doc) => RecurringAppointmentPattern.fromFirestore(doc))
          .toList();
    } catch (e) {
      print('❌ Error getting recurring patterns: $e');
      return [];
    }
  }

  /// Deactivate a recurring pattern
  Future<bool> deactivatePattern(String patternId) async {
    try {
      await _firestore
          .collection('recurringAppointments')
          .doc(patternId)
          .update({'isActive': false});

      print('✅ Recurring pattern deactivated');
      return true;
    } catch (e) {
      print('❌ Error deactivating pattern: $e');
      return false;
    }
  }

  /// Delete future appointments from a pattern
  Future<int> deleteFutureAppointments(String patternId) async {
    try {
      final snapshot = await _firestore
          .collection('appointments')
          .where('recurringPatternId', isEqualTo: patternId)
          .where('startTime', isGreaterThan: Timestamp.now())
          .get();

      final batch = _firestore.batch();
      for (final doc in snapshot.docs) {
        batch.delete(doc.reference);
      }

      await batch.commit();
      print('✅ Deleted ${snapshot.docs.length} future appointments');
      return snapshot.docs.length;
    } catch (e) {
      print('❌ Error deleting future appointments: $e');
      return 0;
    }
  }

  /// Update a recurring pattern and regenerate future appointments
  Future<bool> updatePattern(
    String patternId,
    RecurringAppointmentPattern updatedPattern,
  ) async {
    try {
      // Delete existing future appointments
      await deleteFutureAppointments(patternId);

      // Update the pattern
      await _firestore
          .collection('recurringAppointments')
          .doc(patternId)
          .update(updatedPattern.toFirestore());

      // Generate new appointments
      await createAppointmentsFromPattern(updatedPattern);

      print('✅ Recurring pattern updated');
      return true;
    } catch (e) {
      print('❌ Error updating pattern: $e');
      return false;
    }
  }
}
