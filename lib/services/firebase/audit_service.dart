import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';

enum AuditAction {
  // Patient actions
  patientCreated,
  patientViewed,
  patientUpdated,
  patientDeleted,
  
  // Session actions
  sessionCreated,
  sessionViewed,
  sessionUpdated,
  sessionDeleted,
  
  // Report actions
  reportGenerated,
  reportViewed,
  reportExported,
  
  // Authentication actions
  userLogin,
  userLogout,
  passwordReset,
  
  // Admin actions
  practitionerApproved,
  practitionerRejected,
  practitionerSuspended,
  
  // Profile actions
  profileUpdated,
  profilePhotoUpdated,
  
  // Calendar actions
  appointmentCreated,
  appointmentUpdated,
  appointmentDeleted,
  appointmentCompleted,
  
  // Data export actions
  dataExported,
  pdfExported,
  csvExported,
}

class AuditLog {
  final String id;
  final String userId;
  final String userEmail;
  final String userName;
  final AuditAction action;
  final String actionDescription;
  final DateTime timestamp;
  final Map<String, dynamic> details;
  final String? resourceId;
  final String? resourceType;
  final String? ipAddress;

  AuditLog({
    required this.id,
    required this.userId,
    required this.userEmail,
    required this.userName,
    required this.action,
    required this.actionDescription,
    required this.timestamp,
    required this.details,
    this.resourceId,
    this.resourceType,
    this.ipAddress,
  });

  Map<String, dynamic> toFirestore() {
    return {
      'userId': userId,
      'userEmail': userEmail,
      'userName': userName,
      'action': action.name,
      'actionDescription': actionDescription,
      'timestamp': Timestamp.fromDate(timestamp),
      'details': details,
      'resourceId': resourceId,
      'resourceType': resourceType,
      'ipAddress': ipAddress,
    };
  }

  factory AuditLog.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return AuditLog(
      id: doc.id,
      userId: data['userId'] ?? '',
      userEmail: data['userEmail'] ?? '',
      userName: data['userName'] ?? '',
      action: AuditAction.values.firstWhere(
        (e) => e.name == data['action'],
        orElse: () => AuditAction.patientViewed,
      ),
      actionDescription: data['actionDescription'] ?? '',
      timestamp: (data['timestamp'] as Timestamp).toDate(),
      details: data['details'] ?? {},
      resourceId: data['resourceId'],
      resourceType: data['resourceType'],
      ipAddress: data['ipAddress'],
    );
  }
}

class AuditService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Log an audit event
  Future<void> logEvent({
    required String userId,
    required String userEmail,
    required String userName,
    required AuditAction action,
    required String actionDescription,
    Map<String, dynamic>? details,
    String? resourceId,
    String? resourceType,
    String? ipAddress,
  }) async {
    try {
      final auditLog = AuditLog(
        id: '', // Will be generated by Firestore
        userId: userId,
        userEmail: userEmail,
        userName: userName,
        action: action,
        actionDescription: actionDescription,
        timestamp: DateTime.now(),
        details: details ?? {},
        resourceId: resourceId,
        resourceType: resourceType,
        ipAddress: ipAddress,
      );

      await _firestore.collection('auditLogs').add(auditLog.toFirestore());

      if (kDebugMode) {
        print('✅ Audit log created: ${action.name} by $userName');
      }
    } catch (e) {
      if (kDebugMode) {
        print('❌ Error creating audit log: $e');
      }
      // Don't throw - audit logging should not break the app
    }
  }

  /// Get audit logs for a specific user
  Future<List<AuditLog>> getUserAuditLogs(
    String userId, {
    int limit = 50,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      Query query = _firestore
          .collection('auditLogs')
          .where('userId', isEqualTo: userId)
          .orderBy('timestamp', descending: true)
          .limit(limit);

      if (startDate != null) {
        query = query.where('timestamp', isGreaterThanOrEqualTo: Timestamp.fromDate(startDate));
      }

      if (endDate != null) {
        query = query.where('timestamp', isLessThanOrEqualTo: Timestamp.fromDate(endDate));
      }

      final snapshot = await query.get();
      return snapshot.docs.map((doc) => AuditLog.fromFirestore(doc)).toList();
    } catch (e) {
      if (kDebugMode) {
        print('❌ Error fetching user audit logs: $e');
      }
      return [];
    }
  }

  /// Get audit logs for a specific resource (e.g., patient, session)
  Future<List<AuditLog>> getResourceAuditLogs(
    String resourceId, {
    String? resourceType,
    int limit = 50,
  }) async {
    try {
      Query query = _firestore
          .collection('auditLogs')
          .where('resourceId', isEqualTo: resourceId)
          .orderBy('timestamp', descending: true)
          .limit(limit);

      if (resourceType != null) {
        query = query.where('resourceType', isEqualTo: resourceType);
      }

      final snapshot = await query.get();
      return snapshot.docs.map((doc) => AuditLog.fromFirestore(doc)).toList();
    } catch (e) {
      if (kDebugMode) {
        print('❌ Error fetching resource audit logs: $e');
      }
      return [];
    }
  }

  /// Get all audit logs (admin only)
  Future<List<AuditLog>> getAllAuditLogs({
    int limit = 100,
    DateTime? startDate,
    DateTime? endDate,
    AuditAction? action,
  }) async {
    try {
      Query query = _firestore
          .collection('auditLogs')
          .orderBy('timestamp', descending: true)
          .limit(limit);

      if (startDate != null) {
        query = query.where('timestamp', isGreaterThanOrEqualTo: Timestamp.fromDate(startDate));
      }

      if (endDate != null) {
        query = query.where('timestamp', isLessThanOrEqualTo: Timestamp.fromDate(endDate));
      }

      if (action != null) {
        query = query.where('action', isEqualTo: action.name);
      }

      final snapshot = await query.get();
      return snapshot.docs.map((doc) => AuditLog.fromFirestore(doc)).toList();
    } catch (e) {
      if (kDebugMode) {
        print('❌ Error fetching all audit logs: $e');
      }
      return [];
    }
  }

  /// Get audit log statistics
  Future<Map<String, int>> getAuditStats({
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      Query query = _firestore.collection('auditLogs');

      if (startDate != null) {
        query = query.where('timestamp', isGreaterThanOrEqualTo: Timestamp.fromDate(startDate));
      }

      if (endDate != null) {
        query = query.where('timestamp', isLessThanOrEqualTo: Timestamp.fromDate(endDate));
      }

      final snapshot = await query.get();
      final logs = snapshot.docs.map((doc) => AuditLog.fromFirestore(doc)).toList();

      // Count actions
      final Map<String, int> stats = {};
      for (final log in logs) {
        stats[log.action.name] = (stats[log.action.name] ?? 0) + 1;
      }

      return stats;
    } catch (e) {
      if (kDebugMode) {
        print('❌ Error fetching audit stats: $e');
      }
      return {};
    }
  }

  /// Delete old audit logs (retention policy)
  Future<void> deleteOldLogs({required int daysToKeep}) async {
    try {
      final cutoffDate = DateTime.now().subtract(Duration(days: daysToKeep));
      final snapshot = await _firestore
          .collection('auditLogs')
          .where('timestamp', isLessThan: Timestamp.fromDate(cutoffDate))
          .get();

      final batch = _firestore.batch();
      for (final doc in snapshot.docs) {
        batch.delete(doc.reference);
      }

      await batch.commit();

      if (kDebugMode) {
        print('✅ Deleted ${snapshot.docs.length} old audit logs');
      }
    } catch (e) {
      if (kDebugMode) {
        print('❌ Error deleting old audit logs: $e');
      }
    }
  }
}

